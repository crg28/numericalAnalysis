{% extends "base.html" %}{% load static %}
{% block title %}{{ method.name }}{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/index.css' %}">
{% endblock %}

{% block content %}
<h1>{{ method.name }}</h1>

<div class="method-run">
  <!-- Left: inputs + results -->
  <section class="method-card">
    <h3>Equation</h3>

    <!-- Eq bar for f(x) -->
    <div id="eq_f" class="eq-section">
      <div class="eq-bar">
        <input class="eq-input" id="fx" type="text" placeholder="e.g. sin(x) - x/2">
        <div class="eq-actions">
          <select class="eq-history" title="History"></select>
          <button class="btn btn-outline sm btn-save" type="button">Save</button>
          <button class="btn btn-outline sm btn-graph" type="button">Graph</button>
          <button class="btn btn-outline sm btn-clear" type="button">Clear</button>
        </div>
      </div>
      <div class="preview"></div>
    </div>

    {% if method.kind == 'fixed_point' %}
    <!-- Eq bar for g(x) -->
    <h3 style="margin-top:16px">Iteration function g(x)</h3>
    <div id="eq_g" class="eq-section">
      <div class="eq-bar">
        <input class="eq-input" id="gx" type="text" placeholder="e.g. (sin(x)+x)/2">
        <div class="eq-actions">
          <select class="eq-history" title="History"></select>
          <button class="btn btn-outline sm btn-save" type="button">Save</button>
          <button class="btn btn-outline sm btn-clear" type="button">Clear</button>
        </div>
      </div>
      <div class="preview"></div>
    </div>
    {% endif %}

    <!-- Django form (tol, iter, a/b/x0/x1…) -->
    <form method="post" style="margin-top:16px">
      {% csrf_token %}
      <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;">
        {{ form.as_p }}
      </div>
      <!-- Sincroniza campos de texto con la barra bonita -->
      <input type="hidden" name="funcion" id="hidden_fx">
      {% if method.kind == 'fixed_point' %}
      <input type="hidden" name="gfuncion" id="hidden_gx">
      {% endif %}
      <button class="btn btn-primary" type="submit">Run {{ method.name }}</button>
    </form>

    {% if error %}<div class="note" style="margin-top:10px;color:#c0362c;">{{ error }}</div>{% endif %}

    {% if root is not None %}
      <div class="note" style="margin-top:16px;">
        <h4>Result</h4>
        <p><b>Approx. root:</b> {{ root }}{% if error %}, <b>error</b>: {{ error }}{% endif %}</p>
      </div>
    {% endif %}

    {% if iters %}
      <div class="note" style="margin-top:12px;">
        <h4>Iterations</h4>
        <div style="overflow:auto">
          <table>
            <thead><tr>{% for k,v in iters.0.items %}<th>{{ k }}</th>{% endfor %}</tr></thead>
            <tbody>
              {% for row in iters %}
                <tr>{% for k,v in row.items %}<td>{{ v }}</td>{% endfor %}</tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    {% endif %}
  </section>

  <!-- Right: graph + info -->
  <aside class="right-panel method-card">
    <h3>Grapher</h3>
    <div id="plot" class="plot"></div>

    <div class="note" style="margin-top:16px;">
      <h4>What is this method for?</h4>
      <p>
        {% if "bisection" in method.slug|lower %}
          Find a root by repeatedly bisecting an interval where f(x) changes sign.
        {% elif "newton" in method.slug|lower %}
          Find a root using the tangent line: x_{n+1} = x_n - f(x_n)/f'(x_n).
        {% elif "secant" in method.slug|lower %}
          Derivative-free root finding using the slope through two previous points.
        {% elif method.kind == 'fixed_point' or "fixed" in method.slug|lower %}
          Solve x = g(x) by iteration; convergence depends on how “contractive” g(x) is.
        {% elif "multiple" in method.slug|lower %}
          Variant of Newton’s method designed for multiple roots.
        {% endif %}
      </p>

      <h4>Notes & warnings</h4>
      <p><strong>General note:</strong> Always avoid division by 0 when evaluating formulas.</p>

      {# --- NEWTON --- #}
      {% if "newton" in method.slug|lower %}
        <ul>
          <li>Make sure f(x) is continuous near the expected root.</li>
          <li>Choose an initial guess x₀ close to the root; a poor choice can lead to divergence or convergence to a different root.</li>
          <li>If f′(x) becomes 0 at any step, the update formula fails (division by 0) and the iteration must be stopped or restarted.</li>
          <li>Ensure that f(x) is differentiable on the interval where the method is applied.</li>
        </ul>

      {# --- SECANT --- #}
      {% elif "secant" in method.slug|lower %}
        <ul>
          <li>Use this method when f(x) is continuous near the root but computing f′(x) is inconvenient.</li>
          <li>Pick two starting points so that the root lies “between” them; bad choices may cause divergence.</li>
          <li>If the slope between the last two points is very small, the next step can become extremely large or unstable.</li>
        </ul>

      {# --- FIXED POINT --- #}
      {% elif method.kind == 'fixed_point' or "fixed" in method.slug|lower %}
        <ul>
          <li>Define g(x) so that it is continuous on the interval of interest.</li>
          <li>It is safer when, starting from x₀, the iterates x_{n+1} = g(x_n) stay inside the same interval.</li>
          <li>For convergence, check that |g′(x)| is less than 1 near the fixed point.</li>
        </ul>

      {# --- MULTIPLE ROOTS --- #}
      {% elif "multiple" in method.slug|lower %}
        <ul>
          <li>Ensure that f(x), f′(x) and f″(x) are continuous around the root.</li>
          <li>Monitor denominators in the iteration formula; avoid values where they become 0 or extremely small.</li>
          <li>Use this method when you suspect a multiple root and the theoretical conditions of the formula are satisfied.</li>
        </ul>
      {% endif %}
    </div>
  </aside>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'js/method_ui.js' %}"></script>
<script>
  // Inicializar barras con historial por método (usa slug para la llave)
  const slug = "{{ method.slug }}";
  const barF = NA_UI.initEqBar({
    rootId: 'eq_f',
    storageKey: 'na_hist_f_' + slug,
    onGraph: (fx)=> NA_UI.graphFx('plot', fx)
  });

  // Precargar desde el form de Django (si viene de un POST previo)
  const hiddenFx = document.getElementById('hidden_fx');
  const origFx = document.getElementById('id_funcion');
  if (origFx) { barF.set(origFx.value || ''); }

  {% if method.kind == 'fixed_point' %}
    const barG = NA_UI.initEqBar({
      rootId: 'eq_g',
      storageKey: 'na_hist_g_' + slug
    });
    const hiddenGx = document.getElementById('hidden_gx');
    const origGx = document.getElementById('id_gfuncion');
    if (origGx) { barG.set(origGx.value || ''); }
  {% endif %}

  // Antes de enviar, sincroniza inputs bonitos -> campos del form
  const form = document.querySelector('form[method="post"]');
  form.addEventListener('submit', ()=>{
    if (hiddenFx) hiddenFx.value = barF.get();
    const idFx = document.getElementById('id_funcion');
    if (idFx) idFx.value = barF.get();
    {% if method.kind == 'fixed_point' %}
      if (hiddenGx) hiddenGx.value = barG.get();
      const idG = document.getElementById('id_gfuncion');
      if (idG) idG.value = barG.get();
    {% endif %}
  });
</script>
{% endblock %}
